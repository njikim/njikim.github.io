---
layout: post
title: "Numpy"
description: ""
date: 2019-04-19
tags: [numpy, python]
category: Python
comments: true
share: true
---

## NUMPY
1. 벡터 및 행렬 연산과 관련된 편리한 기능을 제공
2. list와 거의 동일
    - 모든 원소가 같은 자료형이어야 한다
    - 원소의 갯수를 바꿀 수 x
3. 빠른 속도를 지원
4. 벡터화 연산, 배열 인덱싱을 통한 질의 가능

```python
import numpy as np
```

#### 1차원 배열
```python
ar = np.array([10, 20, 20, 31, 45, 56])
print(type(ar))     
print(ar.shape)   

# 벡터화 연산
data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

result = []
for i in data:
    result.append(i*2)
print(result)      

ar = np.array(data)
result = ar*2
print(result)       

result =data*2
print(result)       
```

```result
<class 'numpy.ndarray'>
(6,)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
[ 0  2  4  6  8 10 12 14 16 18]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

#### 2차원 배열
```python
ar = np.array([[0, 1, 2],[3, 4, 5]])
print(ar)
print(len(ar[1]))   
print(ar.shape)     
```

```result
3
(2,3)
```

#### 3차원배열
```python
ar = np.array([[[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12]],
              [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12]]])
print(ar)
print(len(ar), len(ar[0]), len(ar[0][0]))      
print(ar.shape)                                
print(ar.ndim)                                
```

```result
[[[ 1  2  3  4]
[ 5  6  7  8]
[ 9 10 11 12]]
[[ 1  2  3  4]
[ 5  6  7  8]
[ 9 10 11 12]]]

2 3 4
(2, 3, 4)
3
```

#### 배열의 indexing
```python
ar = np.array([0, 1, 2, 3, 4])
print(ar[2], ar[-1])                    

ar1 = np.array([[0, 1, 2],[3, 4, 5]])   
print(ar1[0, 0], ar1[0, 1], ar1[-1, -1])   
```

```result
2 4
0 1 5
```

```python
# fancy indexing
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
idx = np.array([True, False, True, True, False, False, False, True, True, False])
print(a[idx])
print(a%2)
print(a%2 == 0)
print(a[a%2==0])

b = np.array([[1, 2, 3, 4],
              [5, 6, 7, 8],
              [9,10,11,12]])
print(b[[2, 0, 1],:])

c = np.array([i for i in range(1,21)])
print(c)

#? 이 배열에서 3의 배수를 찾아라
#? 이 배열에서 4로 나누면 1이 남는 수를 찾아라
#? 이 배열에서 3으로 나누면 나눠지고 4로 나누면 1이 남는 수를 찾아라
```

```result
[0 2 3 7 8]
[0 1 0 1 0 1 0 1 0 1]
[ True False  True False  True False  True False  True False]
[0 2 4 6 8]
[[ 9 10 11 12]
 [ 1  2  3  4]
 [ 5  6  7  8]]
[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]
```

#### 배열 슬라이싱
```python
a = np.array([[0, 1, 2, 3], [4, 5, 6, 7]])
print(a[0, :])
print(a[:, 1])

#? 두번째 행의 두번째 열부터 끝까지 (5, 6, 7)
print(a[1,1:])
#? 0, 1 
#  4, 5
print(a[:,:2])
```

```result
[0 1 2 3]
[1 5]
[5 6 7]
[[0 1]
 [4 5]]
```

#### numpy의 자료형
- b: boolean
- i: 정수
- u: 부호없는 정수
- f: 부동소수점
- c: 복소 부동소수점
- O: 객체
- S: 바이트 문자열
- U: 유니코드 문자열

```python
a = np.array([1, 2, 3])
print(a.dtype)

a = np.array([1.0, 2.0, 3.0])
print(a.dtype)

a = np.array([1.0, 2.0, 3])
print(a.dtype)

a = np.array([1, 2, 3], dtype='f8')
print(a.dtype)
print(a[0] + a[1])
```

```result
int32
float64
float64
float64
3.0
```

#### 배열 생성
```python 
a = np.zeros(5)
print(a)

b = np.zeros((2, 3), dtype='i')
print(b)

c = np.zeros(5, dtype='U4')
c[0] = 'abc'
c[1] = 'abcd'
c[2] = 'ABCDE'
print(c)

d = np.ones((2, 3, 4))
print(d)

e = np.ones_like(b)
print(e)

f = np.empty((4, 3))
print(f)

g = np.arange(10)
g = np.arange(3, 21, 2)
print(g)

h = np.linspace(0, 100, 5)
print(h)
```

```result
[0. 0. 0. 0. 0.]

[[0 0 0]
 [0 0 0]]

['abc' 'abcd' 'ABCD' '' '']

[[[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]
 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]]

[[1 1 1]
 [1 1 1]]

[[4.24399158e-314 8.48798317e-314 1.27319747e-313]
 [1.69759663e-313 2.12199579e-313 2.54639495e-313]
 [4.24399158e-314 8.48798317e-314 1.27319747e-313]
 [1.69759663e-313 2.12199579e-313 2.54639495e-313]]

[ 3  5  7  9 11 13 15 17 19]

[  0.  25.  50.  75. 100.]
```

#### 전치 연산
```python
a = np.array([[1, 2, 3],[4, 5, 6]])
print(a)
print(a.T)
```

```result
[[1 2 3]
 [4 5 6]]

[[1 4]
 [2 5]
 [3 6]]
```

#### 배열의 크기 변형
```python
a = np.arange(12)
print(a)

b = a.reshape(3, 4)
print(b)

c = a.reshape(3, -1)
print(c)

d = a.reshape(2, 2, 3)
print(d)

e = e.reshape(2, 3, 2)
print(e)
```

```result
[ 0  1  2  3  4  5  6  7  8  9 10 11]

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]

[[[ 0  1  2]
  [ 3  4  5]]
 [[ 6  7  8]
  [ 9 10 11]]]

[[[ 0  1]
  [ 2  3]
  [ 4  5]]
 [[ 6  7]
  [ 8  9]
  [10 11]]]
```

```python
print(e.flatten())      # same as e.ravel())
print(a.reshape(12, 1))  # same as a[:, np.newaxis]
```

```result
[ 0  1  2  3  4  5  6  7  8  9 10 11]
[[ 0]
 [ 1]
 [ 2]
 [ 3]
 [ 4]
 [ 5]
 [ 6]
 [ 7]
 [ 8]
 [ 9]
 [10]
 [11]]
```

#### 배열 연결
```python
a = np.ones((2, 3))
b = np.zeros((2, 2))
print(np.hstack([a, b]))    # 행의 개수가 같을때 

a = np.ones((2, 3))
b = np.zeros((3, 3))
print(np.vstack([a, b]))    # 열의 개수가 같을때

a = np.ones((3, 4))
b = np.zeros((3, 4))
c = np.dstack([a, b])       # 행과 열의 개수가 같을 때
print(c, c.shape)
```

```result
[[1. 1. 1. 0. 0.]
 [1. 1. 1. 0. 0.]]

[[1. 1. 1.]
 [1. 1. 1.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]

 [[1. 0.]
  [1. 0.]
  [1. 0.]
  [1. 0.]]] (3, 4, 2)
```

```python
a = np.ones((3, 4))
b = np.zeros((3, 4))
c = np.stack([a, b], axis=0)    # axis=0 '열' (default)
d = np.stack([a, b], axis=1)    # axis=1 '행'
print(c , c.shape)
print(d, d.shape)
```

```result
[[[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]
 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]] (2, 3, 4)

[[[1. 1. 1. 1.]
  [0. 0. 0. 0.]]
 [[1. 1. 1. 1.]
  [0. 0. 0. 0.]]
 [[1. 1. 1. 1.]
  [0. 0. 0. 0.]]] (3, 2, 4)
```

```python
a = np.array([[0, 1, 2], [3, 4, 5]])
print(np.tile(a, 2))
print(np.tile(a, (3,2)))
```

```result
[[0 1 2 0 1 2]
 [3 4 5 3 4 5]]

[[0 1 2 0 1 2]
 [3 4 5 3 4 5]
 [0 1 2 0 1 2]
 [3 4 5 3 4 5]
 [0 1 2 0 1 2]
 [3 4 5 3 4 5]]
```
#### 2차원 그리드 포인트 생성: meshgrid()
```python
x = np.arange(3)
y = np.arange(5)

X, Y = np.meshgrid(x, y)
print(X)
print('----------')
print(Y)

Z = [list(zip(x, y)) for x,y in zip(X, Y)]
print(Z)
```

```output
[[0 1 2]
 [0 1 2]
 [0 1 2]
 [0 1 2]
 [0 1 2]]
----------
[[0 0 0]
 [1 1 1]
 [2 2 2]
 [3 3 3]
 [4 4 4]]

[[(0, 0), (1, 0), (2, 0)], [(0, 1), (1, 1), (2, 1)], [(0, 2), (1, 2), (2, 2)], [(0, 3), (1, 3), (2, 3)], [(0, 4), (1, 4), (2, 4)]]
```