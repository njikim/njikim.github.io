---
layout: post
title: "SQL (1)"
description: "Select"
date: 2019-03-27
tags: [SQL, SQL SELECT, SQL ORDER BY, SQL WHERE, SQL LIKE, SQL FUNCTIONS]
category: Select, Order by, Where, Like, Functions
comments: true
share: true
---

## 1. SELECT
- 실행순서: FROM 절 -> SELECT 절

```sql
SELECT fieldnames
FROM tablename;
```
<br>

```sql
-- field의 가공처리
SELECT empno, ename, sal+100 FROM scott_emp;
```
```
+-------+--------+---------+
| empno | ename  | sal+100 |
+-------+--------+---------+
|  7369 | SMITH  |     900 |
|  7499 | ALLEN  |    1700 |
|  7521 | WARD   |    1350 |
|  7566 | JONES  |    3075 |
|  7654 | MARTIN |    1350 |
|  7698 | BLAKE  |    2950 |
|  7782 | CLARK  |    2550 |
|  7788 | SCOTT  |    3100 |
|  7839 | KING   |    5100 |
|  7844 | TURNER |    1600 |
|  7876 | ADAMS  |    1200 |
|  7900 | JAMES  |    1050 |
|  7902 | FORD   |    3100 |
|  7934 | MILLER |    1400 |
+-------+--------+---------+
```
<br>

```sql
-- field alias
SELECT empno, ename, mgr manager FROM scott_emp;
SELECT empno, ename, mgr as manager FROM scott_emp;
SELECT empno, ename, mgr as 'my manager' FROM scott_emp;
```
```
+-------+--------+------------+
| empno | ename  | my manager |
+-------+--------+------------+
|  7369 | SMITH  |       7902 |
|  7499 | ALLEN  |       7698 |
|  7521 | WARD   |       7698 |
|  7566 | JONES  |       7839 |
|  7654 | MARTIN |       7698 |
|  7698 | BLAKE  |       7839 |
|  7782 | CLARK  |       7839 |
|  7788 | SCOTT  |       7566 |
|  7839 | KING   |       NULL |
|  7844 | TURNER |       7698 |
|  7876 | ADAMS  |       7788 |
|  7900 | JAMES  |       7698 |
|  7902 | FORD   |       7566 |
|  7934 | MILLER |       7782 |
+-------+--------+------------+
```
<br>

```sql
-- 중복 제거: distinct
SELECT job FROM scott_emp;
```
```
+-----------+
| job       |
+-----------+
| CLERK     |
| SALESMAN  |
| SALESMAN  |
| MANAGER   |
| SALESMAN  |
| MANAGER   |
| MANAGER   |
| ANALYST   |
| PRESIDENT |
| SALESMAN  |
| CLERK     |
| CLERK     |
| ANALYST   |
| CLERK     |
+-----------+
```
```sql
SELECT distinct job FROM scott_emp;
```
```
+-----------+
| job       |
+-----------+
| CLERK     |
| SALESMAN  |
| MANAGER   |
| ANALYST   |
| PRESIDENT |
+-----------+
```
<br>

## 2. 확장 문법
### 2.1. 정렬 기능: ORDER BY
- 실행순서: FROM 절 -> SELECT 절 -> ORDER BY 절
- **Note: 정렬 기능은 항상 제일 마지막에**

```sql
SELECT fieldnames
FROM tablename
ORDER BY fieldnames;
```
<br>

```sql
-- 급여가 많은 순으로 이름, 급여, 부서코드를 조회
SELECT ename, sal, deptno 
FROM scott_emp
ORDER BY sal DESC;
```
```
+--------+------+--------+
| ename  | sal  | deptno |
+--------+------+--------+
| KING   | 5000 |     10 |
| SCOTT  | 3000 |     20 |
| FORD   | 3000 |     20 |
| JONES  | 2975 |     20 |
| BLAKE  | 2850 |     30 |
| CLARK  | 2450 |     10 |
| ALLEN  | 1600 |     30 |
| TURNER | 1500 |     30 |
| MILLER | 1300 |     10 |
| WARD   | 1250 |     30 |
| MARTIN | 1250 |     30 |
| ADAMS  | 1100 |     20 |
| JAMES  |  950 |     30 |
| SMITH  |  800 |     20 |
+--------+------+--------+
```
<br>

```sql
-- 부서별로 급여가 적은 순으로 이름, 급여, 부서코드 조회
SELECT ename, sal, deptno 
FROM scott_emp
ORDER BY deptno, sal;
```
```
+--------+------+--------+
| ename  | sal  | deptno |
+--------+------+--------+
| MILLER | 1300 |     10 |
| CLARK  | 2450 |     10 |
| KING   | 5000 |     10 |
| SMITH  |  800 |     20 |
| ADAMS  | 1100 |     20 |
| JONES  | 2975 |     20 |
| SCOTT  | 3000 |     20 |
| FORD   | 3000 |     20 |
| JAMES  |  950 |     30 |
| WARD   | 1250 |     30 |
| MARTIN | 1250 |     30 |
| TURNER | 1500 |     30 |
| ALLEN  | 1600 |     30 |
| BLAKE  | 2850 |     30 |
+--------+------+--------+
```
<br>

### 2.2. 조건 기능 (레코드 필터링): WHERE 
- 실행순서: FROM 절 -> WHERE 절 -> SELECT 절
  
```sql
SELECT fieldnames
FROM tablename
WHERE blah blah
```
<br>

```sql
-- 급여가 3000$ 이상인 직원의 사번, 이름, 급여를 조회
SELECT empno, ename, sal 
FROM scott_emp
WHERE sal >= 3000;
```
```
+-------+-------+------+
| empno | ename | sal  |
+-------+-------+------+
|  7788 | SCOTT | 3000 |
|  7839 | KING  | 5000 |
|  7902 | FORD  | 3000 |
+-------+-------+------+
```
<br>

```sql
-- 업무가 manager인 직원의 이름, 부서, 업무, 급여 조회
SELECT empno, ename, sal 
FROM scott_emp
WHERE job = 'manager';
```
```
+-------+-------+------+
| empno | ename | sal  |
+-------+-------+------+
|  7566 | JONES | 2975 |
|  7698 | BLAKE | 2850 |
|  7782 | CLARK | 2450 |
+-------+-------+------+
```
<br>

```sql
-- 부서가 20이고 업무가 analyst인 직원의 이름, 부서, 업무, 급여 조회
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE deptno = 20 AND job = 'Analyst';
```
```
+-------+--------+---------+------+
| ename | deptno | job     | sal  |
+-------+--------+---------+------+
| SCOTT |     20 | ANALYST | 3000 |
| FORD  |     20 | ANALYST | 3000 |
+-------+--------+---------+------+
```
<br>

```sql
-- 급여가 1500 이상 2500 미만을 받는 직원의 이름, 부서, 업무 급여를 조회 (단, 급여가 많은 순으로 조회)
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE sal >= 1500 AND sal <= 2000
ORDER BY sal DESC;

-- !!Note: BETWEEN AND는 '이상, 이하' 일 때만 쓸 수 있음
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE sal BETWEEN 1500 AND 2000;
```
```
+--------+--------+----------+------+
| ename  | deptno | job      | sal  |
+--------+--------+----------+------+
| ALLEN  |     30 | SALESMAN | 1600 |
| TURNER |     30 | SALESMAN | 1500 |
+--------+--------+----------+------+
```
<br>

```sql
-- 업무가 clerk, salesman, analyst인 직원의 이름, 부서, 업무, 급여 조회
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE job = 'clerk' OR job = 'salesman' OR job = 'analyst';

-- !!Note: IN은 'OR 조건' 일 때만 쓸 수 있음
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE job IN ('clerk', 'salesman', 'analyst');
```
```
+--------+--------+----------+------+
| ename  | deptno | job      | sal  |
+--------+--------+----------+------+
| SMITH  |     20 | CLERK    |  800 |
| ALLEN  |     30 | SALESMAN | 1600 |
| WARD   |     30 | SALESMAN | 1250 |
| MARTIN |     30 | SALESMAN | 1250 |
| SCOTT  |     20 | ANALYST  | 3000 |
| TURNER |     30 | SALESMAN | 1500 |
| ADAMS  |     20 | CLERK    | 1100 |
| JAMES  |     30 | CLERK    |  950 |
| FORD   |     20 | ANALYST  | 3000 |
| MILLER |     10 | CLERK    | 1300 |
+--------+--------+----------+------+
```
<br>

```sql
-- 1982/01/01 이후에 입사한 직원의 이름, 업무, 입사일자 조회
-- Note: SQL에서 날짜는 문자열 형식, 날짜형식만 유지하면 구분자는 상관없음
SELECT ename, job, hiredate 
FROM scott_emp
WHERE hiredate > '1982-01-01';
WHERE hiredate > '1982/01/01';
WHERE hiredate > '1982,01,01';
```
```
+--------+---------+---------------------+
| ename  | job     | hiredate            |
+--------+---------+---------------------+
| SCOTT  | ANALYST | 1987-04-19 00:00:00 |
| ADAMS  | CLERK   | 1987-05-23 00:00:00 |
| MILLER | CLERK   | 1982-01-23 00:00:00 |
+--------+---------+---------------------+
```
<br>

```sql
-- 커미션이 없는 직원의 이름, 부서, 업무, 급여, 커미션 조회
SELECT ename, empno, job, sal, comm 
FROM scott_emp
WHERE comm IS null;
```
```
+--------+-------+-----------+------+------+
| ename  | empno | job       | sal  | comm |
+--------+-------+-----------+------+------+
| SMITH  |  7369 | CLERK     |  800 | NULL |
| JONES  |  7566 | MANAGER   | 2975 | NULL |
| BLAKE  |  7698 | MANAGER   | 2850 | NULL |
| CLARK  |  7782 | MANAGER   | 2450 | NULL |
| SCOTT  |  7788 | ANALYST   | 3000 | NULL |
| KING   |  7839 | PRESIDENT | 5000 | NULL |
| ADAMS  |  7876 | CLERK     | 1100 | NULL |
| JAMES  |  7900 | CLERK     |  950 | NULL |
| FORD   |  7902 | ANALYST   | 3000 | NULL |
| MILLER |  7934 | CLERK     | 1300 | NULL |
+--------+-------+-----------+------+------+
```
<br>

```sql
-- 커미션이 있는 직원
SELECT ename, empno, job, sal, comm 
FROM scott_emp
WHERE comm IS NOT null;

SELECT ename, empno, job, sal, comm 
FROM scott_emp
WHERE comm >= 0;
```
```
+--------+-------+----------+------+------+
| ename  | empno | job      | sal  | comm |
+--------+-------+----------+------+------+
| ALLEN  |  7499 | SALESMAN | 1600 |  300 |
| WARD   |  7521 | SALESMAN | 1250 |  500 |
| MARTIN |  7654 | SALESMAN | 1250 | 1400 |
| TURNER |  7844 | SALESMAN | 1500 |    0 |
+--------+-------+----------+------+------+
```
<br>

### 2.3. Like 연산자
- % : 0개 이상의 문자 대체
- _ : 1개 문자 대체
- 예시: beau% - beau, beaut, beauti, ..
- 예시: beau__ - beauab, beauti, beaufl ..

```sql
-- 이름이 s로 끝나는 직원의 이름, 업무, 급여를 조회
SELECT ename, job, sal FROM scott_emp
	WHERE ename like '%s';
```
```
+-------+---------+------+
| ename | job     | sal  |
+-------+---------+------+
| JONES | MANAGER | 2975 |
| ADAMS | CLERK   | 1100 |
| JAMES | CLERK   |  950 |
+-------+---------+------+
```
<br>

### 2.4. GROUP BY & HAVING 조건
- Group by 절: 특정 컬럼 값을 기준으로 그룹화
- Having 절: 그룹으로 묶은 뒤, 조건이 있는 경우

```sql
-- 부서별로 급여 평균, 최저 급여 조회
SELECT deptno, round(avg(sal)), round(min(sal))
FROM scott_emp
GROUP BY deptno;

-- 부서별로 급여 평균, 최저 급여 조회 (급여 평균이 높은 순으로)
SELECT deptno, round(avg(sal)), round(min(sal))
FROM scott_emp
GROUP BY deptno
ORDER BY avg(sal) DESC;
```
<br>

```sql
-- 전체 급여의 합계가 5000을 초과하는 업무에 대해서 급여 합계 조회
SELECT job, sum(sal) 
FROM scott_emp
/* WHERE sum(sal) > 5000 오류발생 */
GROUP BY job
HAVING sum(sal) > 5000;

-- 전체 급여의 합계가 5000을 초과하는 업무에 대해서 급여 합계 조회 (단, salesman 제외)
-- 두 방식에 성능 차이가 있을 수 있음 (아래 방식이 성능이 더 좋을 수 있을 수도)
SELECT job, sum(sal) 
FROM scott_emp
GROUP BY job
HAVING sum(sal) > 5000 AND job <> 'salesman';

SELECT job, sum(sal) 
FROM scott_emp
WHERE job <> 'salesman'
GROUP BY job
HAVING sum(sal) > 5000;
```
<br>

## 3. 함수
### 3.1. Single-Row Function (단일행 함수)
- String Function:
	- ASCII( ), CHAR()
	- LENGTH()
	- INSTR()
	- LEFT(), RIGHT(), SUBSTR(), SUBSTRING()


```sql
SELECT ASCII('a');
	--> 97
SELECT CHAR(98);
	--> b

SELECT LENGTH(ename) FROM scott_emp;

SELECT INSTR('foobarbar', 'bar');
	--> 4
SELECT INSTR('foobarbar', 'love');
	--> 0

SELECT LEFT('abcdefg', 3);
	--> abc
SELECT RIGHT('abcdefg', 4);
	--> defg
SELECT SUBSTRING('i lovee SQL', 3);
	--> lovee SQL
SELECT SUBSTRING('i lovee SQL', 3, 4);
	--> love
SELECT SUBSTRING('i lovee sql', -3);
	--> sql
SELECT SUBSTRING('i lovee sql', -9, 5);
	--> lovee
```
<br>

- Numeric Function
	- CEIL(), FLOOR(), ROUND(), TRUNCATE()
	- MOD()
	- RAND()
  
```sql
SELECT CEIL(1.23);
	--> 2
SELECT FLOOR(1.73);
	--> 1
SELECT ROUND(1.23), ROUND(1.73);
	--> 1 | 2
SELECT ROUND(1.298, 1);
	--> 1.3
SELECT TRUNCATE(1.73, 0);
	--> 1
```
<br>

- Date Function

```sql
-- NOW(), SYSDATE(), CURDATE(), CURTIME()
SELECT NOW();
```
```
+---------------------+
| NOW()               |
+---------------------+
| 2019-03-27 16:37:04 |
+---------------------+
```
```sql
-- YEAR(), MONTH(), DAYOFMONTH()
SELECT YEAR(NOW()), MONTH(NOW());
```
```
+-------------+--------------+
| YEAR(NOW()) | MONTH(NOW()) |
+-------------+--------------+
|        2019 |            3 |
+-------------+--------------+
```
```sql
-- DAYOFWEEK(): 1-일요일, WEEKDAY(): 0-월요일
SELECT DAYOFWEEK(NOW()), WEEKDAY(NOW());
```
```
+------------------+----------------+
| DAYOFWEEK(NOW()) | WEEKDAY(NOW()) |
+------------------+----------------+
|                4 |              2 |
+------------------+----------------+
```
```sql
-- DAOFYEAR(): 1년 중 며칠이 지났는지 알려줌
SELECT DAYOFYEAR(NOW());
```
```
+------------------+
| DAYOFYEAR(NOW()) |
+------------------+
|               86 |
+------------------+
```
```sql
-- DATE_ADD(), DATE_SUB()
SELECT DATE_ADD(NOW(), interval 5 YEAR), DATE_ADD(NOW(), interval 5 DAY);
```
```
+----------------------------------+---------------------------------+
| DATE_ADD(NOW(), interval 5 YEAR) | DATE_ADD(NOW(), interval 5 DAY) |
+----------------------------------+---------------------------------+
| 2024-03-27 16:48:21              | 2019-04-01 16:48:21             |
+----------------------------------+---------------------------------+
```
<br>

### 3.2. Aggregation Function
- SUM(), AVG(), COUNT(), MAX(), MIN()

### 3.3. 기타
```sql
-- CONVERT()
SELECT CONVERT('2019-5-1', DATE);
SELECT CONVERT(150, CHAR);
SELECT CONVERT('14:06:10', TIME);
```
  
```sql
-- CASE()
-- 업무가 salesman이면 'yes' 이라고하고, 그 외 업무는 'no' 라고 조회
SELECT ename, job, comm,
	CASE 
		WHEN job='salesman' THEN 'yes'
		ELSE 'no'
	END iscomm
FROM scott_emp;
```
```
+--------+-----------+--------+
| ename  | comm      | iscomm |
+--------+-----------+--------+
| SMITH  | CLERK     | no     |
| ALLEN  | SALESMAN  | yes    |
| WARD   | SALESMAN  | yes    |
| JONES  | MANAGER   | no     |
| MARTIN | SALESMAN  | yes    |
| BLAKE  | MANAGER   | no     |
| CLARK  | MANAGER   | no     |
| SCOTT  | ANALYST   | no     |
| KING   | PRESIDENT | no     |
| TURNER | SALESMAN  | yes    |
| ADAMS  | CLERK     | no     |
| JAMES  | CLERK     | no     |
| FORD   | ANALYST   | no     |
| MILLER | CLERK     | no     |
+--------+-----------+--------+
```

```sql
-- COALESCE()
-- 현재 직원들의 총 급여를 조회
SELECT empno, ename, sal, comm, (sal+comm) as total FROM scott_emp; --null값 처리가 안됨
SELECT empno, ename, sal, comm,
	(sal+COALESCE(comm, 0)) as total
	FROM scott_emp;
```



