---
layout: post
title: "SQL (1)"
description: "Select"
date: 2019-03-27
tags: [SQL, SQL SELECT, SQL ORDER BY, SQL WHERE, SQL LIKE, SQL FUNCTIONS]
category: Select, Order by, Where, Like, Functions
comments: true
share: true
---

## 1. SELECT
- 실행순서: FROM 절 -> SELECT 절

```sql
SELECT fieldnames
FROM tablename;
```
<br>

```sql
-- field의 가공처리
SELECT empno, ename, sal+100 FROM scott_emp;
```
```
+-------+--------+---------+
| empno | ename  | sal+100 |
+-------+--------+---------+
|  7369 | SMITH  |     900 |
|  7499 | ALLEN  |    1700 |
|  7521 | WARD   |    1350 |
|  7566 | JONES  |    3075 |
|  7654 | MARTIN |    1350 |
|  7698 | BLAKE  |    2950 |
|  7782 | CLARK  |    2550 |
|  7788 | SCOTT  |    3100 |
|  7839 | KING   |    5100 |
|  7844 | TURNER |    1600 |
|  7876 | ADAMS  |    1200 |
|  7900 | JAMES  |    1050 |
|  7902 | FORD   |    3100 |
|  7934 | MILLER |    1400 |
+-------+--------+---------+
```
<br>

```sql
-- field alias
SELECT empno, ename, mgr manager FROM scott_emp;
SELECT empno, ename, mgr as manager FROM scott_emp;
SELECT empno, ename, mgr as 'my manager' FROM scott_emp;
```
```
+-------+--------+------------+
| empno | ename  | my manager |
+-------+--------+------------+
|  7369 | SMITH  |       7902 |
|  7499 | ALLEN  |       7698 |
|  7521 | WARD   |       7698 |
|  7566 | JONES  |       7839 |
|  7654 | MARTIN |       7698 |
|  7698 | BLAKE  |       7839 |
|  7782 | CLARK  |       7839 |
|  7788 | SCOTT  |       7566 |
|  7839 | KING   |       NULL |
|  7844 | TURNER |       7698 |
|  7876 | ADAMS  |       7788 |
|  7900 | JAMES  |       7698 |
|  7902 | FORD   |       7566 |
|  7934 | MILLER |       7782 |
+-------+--------+------------+
```
<br>

```sql
-- 중복 제거: distinct
SELECT job FROM scott_emp;
```
```
+-----------+
| job       |
+-----------+
| CLERK     |
| SALESMAN  |
| SALESMAN  |
| MANAGER   |
| SALESMAN  |
| MANAGER   |
| MANAGER   |
| ANALYST   |
| PRESIDENT |
| SALESMAN  |
| CLERK     |
| CLERK     |
| ANALYST   |
| CLERK     |
+-----------+
```
```sql
SELECT distinct job FROM scott_emp;
```
```
+-----------+
| job       |
+-----------+
| CLERK     |
| SALESMAN  |
| MANAGER   |
| ANALYST   |
| PRESIDENT |
+-----------+
```
<br>

## 2. 확장 문법
### 2.1. 정렬 기능: ORDER BY
- 실행순서: FROM 절 -> SELECT 절 -> ORDER BY 절
- **Note: 정렬 기능은 항상 제일 마지막에**

```sql
SELECT fieldnames
FROM tablename
ORDER BY fieldnames;
```
<br>

```sql
-- 급여가 많은 순으로 이름, 급여, 부서코드를 조회
SELECT ename, sal, deptno 
FROM scott_emp
ORDER BY sal DESC;
```
```
+--------+------+--------+
| ename  | sal  | deptno |
+--------+------+--------+
| KING   | 5000 |     10 |
| SCOTT  | 3000 |     20 |
| FORD   | 3000 |     20 |
| JONES  | 2975 |     20 |
| BLAKE  | 2850 |     30 |
| CLARK  | 2450 |     10 |
| ALLEN  | 1600 |     30 |
| TURNER | 1500 |     30 |
| MILLER | 1300 |     10 |
| WARD   | 1250 |     30 |
| MARTIN | 1250 |     30 |
| ADAMS  | 1100 |     20 |
| JAMES  |  950 |     30 |
| SMITH  |  800 |     20 |
+--------+------+--------+
```
<br>

```sql
-- 부서별로 급여가 적은 순으로 이름, 급여, 부서코드 조회
SELECT ename, sal, deptno 
FROM scott_emp
ORDER BY deptno, sal;
```
```
+--------+------+--------+
| ename  | sal  | deptno |
+--------+------+--------+
| MILLER | 1300 |     10 |
| CLARK  | 2450 |     10 |
| KING   | 5000 |     10 |
| SMITH  |  800 |     20 |
| ADAMS  | 1100 |     20 |
| JONES  | 2975 |     20 |
| SCOTT  | 3000 |     20 |
| FORD   | 3000 |     20 |
| JAMES  |  950 |     30 |
| WARD   | 1250 |     30 |
| MARTIN | 1250 |     30 |
| TURNER | 1500 |     30 |
| ALLEN  | 1600 |     30 |
| BLAKE  | 2850 |     30 |
+--------+------+--------+
```
<br>

### 2.2. 조건 기능 (레코드 필터링): WHERE 
- 실행순서: FROM 절 -> WHERE 절 -> SELECT 절
  
```sql
SELECT fieldnames
FROM tablename
WHERE blah blah
```
<br>

```sql
-- 급여가 3000$ 이상인 직원의 사번, 이름, 급여를 조회
SELECT empno, ename, sal 
FROM scott_emp
WHERE sal >= 3000;
```
```
+-------+-------+------+
| empno | ename | sal  |
+-------+-------+------+
|  7788 | SCOTT | 3000 |
|  7839 | KING  | 5000 |
|  7902 | FORD  | 3000 |
+-------+-------+------+
```
<br>

```sql
-- 업무가 manager인 직원의 이름, 부서, 업무, 급여 조회
SELECT empno, ename, sal 
FROM scott_emp
WHERE job = 'manager';
```
```
+-------+-------+------+
| empno | ename | sal  |
+-------+-------+------+
|  7566 | JONES | 2975 |
|  7698 | BLAKE | 2850 |
|  7782 | CLARK | 2450 |
+-------+-------+------+
```
<br>

```sql
-- 부서가 20이고 업무가 analyst인 직원의 이름, 부서, 업무, 급여 조회
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE deptno = 20 AND job = 'Analyst';
```
```
+-------+--------+---------+------+
| ename | deptno | job     | sal  |
+-------+--------+---------+------+
| SCOTT |     20 | ANALYST | 3000 |
| FORD  |     20 | ANALYST | 3000 |
+-------+--------+---------+------+
```
<br>

```sql
-- 급여가 1500 이상 2500 미만을 받는 직원의 이름, 부서, 업무 급여를 조회 (단, 급여가 많은 순으로 조회)
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE sal >= 1500 AND sal <= 2000
ORDER BY sal DESC;

-- !!Note: BETWEEN AND는 '이상, 이하' 일 때만 쓸 수 있음
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE sal BETWEEN 1500 AND 2000;
```
```
+--------+--------+----------+------+
| ename  | deptno | job      | sal  |
+--------+--------+----------+------+
| ALLEN  |     30 | SALESMAN | 1600 |
| TURNER |     30 | SALESMAN | 1500 |
+--------+--------+----------+------+
```
<br>

```sql
-- 업무가 clerk, salesman, analyst인 직원의 이름, 부서, 업무, 급여 조회
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE job = 'clerk' OR job = 'salesman' OR job = 'analyst';

-- !!Note: IN은 'OR 조건' 일 때만 쓸 수 있음
SELECT ename, deptno, job, sal 
FROM scott_emp
WHERE job IN ('clerk', 'salesman', 'analyst');
```
```
+--------+--------+----------+------+
| ename  | deptno | job      | sal  |
+--------+--------+----------+------+
| SMITH  |     20 | CLERK    |  800 |
| ALLEN  |     30 | SALESMAN | 1600 |
| WARD   |     30 | SALESMAN | 1250 |
| MARTIN |     30 | SALESMAN | 1250 |
| SCOTT  |     20 | ANALYST  | 3000 |
| TURNER |     30 | SALESMAN | 1500 |
| ADAMS  |     20 | CLERK    | 1100 |
| JAMES  |     30 | CLERK    |  950 |
| FORD   |     20 | ANALYST  | 3000 |
| MILLER |     10 | CLERK    | 1300 |
+--------+--------+----------+------+
```
<br>

```sql
-- 1982/01/01 이후에 입사한 직원의 이름, 업무, 입사일자 조회
-- Note: SQL에서 날짜는 문자열 형식, 날짜형식만 유지하면 구분자는 상관없음
SELECT ename, job, hiredate 
FROM scott_emp
WHERE hiredate > '1982-01-01';
WHERE hiredate > '1982/01/01';
WHERE hiredate > '1982,01,01';
```
```
+--------+---------+---------------------+
| ename  | job     | hiredate            |
+--------+---------+---------------------+
| SCOTT  | ANALYST | 1987-04-19 00:00:00 |
| ADAMS  | CLERK   | 1987-05-23 00:00:00 |
| MILLER | CLERK   | 1982-01-23 00:00:00 |
+--------+---------+---------------------+
```
<br>

```sql
-- 커미션이 없는 직원의 이름, 부서, 업무, 급여, 커미션 조회
SELECT ename, empno, job, sal, comm 
FROM scott_emp
WHERE comm IS null;
```
```
+--------+-------+-----------+------+------+
| ename  | empno | job       | sal  | comm |
+--------+-------+-----------+------+------+
| SMITH  |  7369 | CLERK     |  800 | NULL |
| JONES  |  7566 | MANAGER   | 2975 | NULL |
| BLAKE  |  7698 | MANAGER   | 2850 | NULL |
| CLARK  |  7782 | MANAGER   | 2450 | NULL |
| SCOTT  |  7788 | ANALYST   | 3000 | NULL |
| KING   |  7839 | PRESIDENT | 5000 | NULL |
| ADAMS  |  7876 | CLERK     | 1100 | NULL |
| JAMES  |  7900 | CLERK     |  950 | NULL |
| FORD   |  7902 | ANALYST   | 3000 | NULL |
| MILLER |  7934 | CLERK     | 1300 | NULL |
+--------+-------+-----------+------+------+
```
<br>

```sql
-- 커미션이 있는 직원
SELECT ename, empno, job, sal, comm 
FROM scott_emp
WHERE comm IS NOT null;

SELECT ename, empno, job, sal, comm 
FROM scott_emp
WHERE comm >= 0;
```
```
+--------+-------+----------+------+------+
| ename  | empno | job      | sal  | comm |
+--------+-------+----------+------+------+
| ALLEN  |  7499 | SALESMAN | 1600 |  300 |
| WARD   |  7521 | SALESMAN | 1250 |  500 |
| MARTIN |  7654 | SALESMAN | 1250 | 1400 |
| TURNER |  7844 | SALESMAN | 1500 |    0 |
+--------+-------+----------+------+------+
```
<br>

### 2.3. Like 연산자
- % : 0개 이상의 문자 대체
- _ : 1개 문자 대체
- 예시: beau% - beau, beaut, beauti, ..
- 예시: beau__ - beauab, beauti, beaufl ..

```sql
-- 이름이 s로 끝나는 직원의 이름, 업무, 급여를 조회
SELECT ename, job, sal FROM scott_emp
	WHERE ename like '%s';
```
```
+-------+---------+------+
| ename | job     | sal  |
+-------+---------+------+
| JONES | MANAGER | 2975 |
| ADAMS | CLERK   | 1100 |
| JAMES | CLERK   |  950 |
+-------+---------+------+
```
<br>

### 2.4. GROUP BY & HAVING 조건
- Group by 절: 특정 컬럼 값을 기준으로 그룹화
- Having 절: 그룹으로 묶은 뒤, 조건이 있는 경우
```sql
-- 부서별로 급여 평균, 최저 급여 조회
SELECT deptno, round(avg(sal)), round(min(sal))
FROM scott_emp
GROUP BY deptno;

-- 부서별로 급여 평균, 최저 급여 조회 (급여 평균이 높은 순으로)
SELECT deptno, round(avg(sal)), round(min(sal))
FROM scott_emp
GROUP BY deptno
ORDER BY avg(sal) DESC;
```
<br>

```sql
-- 전체 급여의 합계가 5000을 초과하는 업무에 대해서 급여 합계 조회
SELECT job, sum(sal) 
FROM scott_emp
/* WHERE sum(sal) > 5000 오류발생 */
GROUP BY job
HAVING sum(sal) > 5000;

-- 전체 급여의 합계가 5000을 초과하는 업무에 대해서 급여 합계 조회 (단, salesman 제외)
-- 두 방식에 성능 차이가 있을 수 있음 (아래 방식이 성능이 더 좋을 수 있을 수도)
SELECT job, sum(sal) 
FROM scott_emp
GROUP BY job
HAVING sum(sal) > 5000 AND job <> 'salesman';

SELECT job, sum(sal) 
FROM scott_emp
WHERE job <> 'salesman'
GROUP BY job
HAVING sum(sal) > 5000;
```
<br>

### 연습문제
```sql
-- 1. 1981년에 입사한 사람의 이름, 업무, 입사일자 조회
SELECT ename, job, hiredate 
FROM scott_emp
WHERE hiredate > '1981-01-01' AND hiredate < '1981-12-31';

-- 2. 사번이 7902, 7788, 7566인 사원의 이름, 업무, 급여, 입사일자 조회
SELECT ename, job, hiredate 
FROM scott_emp
WHERE empno IN (7902, 7788, 7566);

-- 3. 업무가 manager, clerk, analyst가 아닌 직원의 이름, 업무, 급여, 부서번호 조회
SELECT ename, job, empno 
FROM scott_emp
WHERE job NOT IN ('manager', 'clerk', 'analyst');

-- 4. 업무가 president 또는 salesman이고 급여가 1500인 직원의 이름, 급여, 업무, 부서번호 조회
SELECT ename, sal, job, empno 
FROM scott_emp
WHERE job IN ('president', 'salesman') AND sal = 1500;

-- 5. 가장 최근에 입사한 직원의 이름, 부서, 업무, 입사일자 조회 (현재 검색 일자가 1987년이라 가정)
SELECT ename, deptno, job, max(hiredate) 
FROM scott_emp;

-- 6. 같은 부서내에서 같은 업무를 하는 직원의 급여가 많은 순으로 조회
SELECT * FROM scott_emp
ORDER BY job, sal DESC;

-- 7. 커미션이 급여보다 10%이상 많은 직원의 급여가 많은 순으로 조회
SELECT * FROM scott_emp
WHERE comm >= sal*0.1;
```

## 3. 함수
### 3.1. Single-Row Function (단일행 함수)
- String Function:
	- ASCII( ), CHAR()
	- LENGTH()
	- INSTR()
	- LEFT(), RIGHT(), SUBSTR(), SUBSTRING()


```sql
SELECT ASCII('a');
	--> 97
SELECT CHAR(98);
	--> b

SELECT LENGTH(ename) FROM scott_emp;

SELECT INSTR('foobarbar', 'bar');
	--> 4
SELECT INSTR('foobarbar', 'love');
	--> 0

SELECT LEFT('abcdefg', 3);
	--> abc
SELECT RIGHT('abcdefg', 4);
	--> defg
SELECT SUBSTRING('i lovee SQL', 3);
	--> lovee SQL
SELECT SUBSTRING('i lovee SQL', 3, 4);
	--> love
SELECT SUBSTRING('i lovee sql', -3);
	--> sql
SELECT SUBSTRING('i lovee sql', -9, 5);
	--> lovee
```
<br>

- Numeric Function
	- CEIL(), FLOOR(), ROUND(), TRUNCATE()
	- MOD()
	- RAND()
  
```sql
SELECT CEIL(1.23);
	--> 2
SELECT FLOOR(1.73);
	--> 1
SELECT ROUND(1.23), ROUND(1.73);
	--> 1 | 2
SELECT ROUND(1.298, 1);
	--> 1.3
SELECT TRUNCATE(1.73, 0);
	--> 1
```
<br>

- Date Function
```sql
-- NOW(), SYSDATE(), CURDATE(), CURTIME()
SELECT NOW();
```
```
+---------------------+
| NOW()               |
+---------------------+
| 2019-03-27 16:37:04 |
+---------------------+
```
```sql
-- YEAR(), MONTH(), DAYOFMONTH()
SELECT YEAR(NOW()), MONTH(NOW());
```
```
+-------------+--------------+
| YEAR(NOW()) | MONTH(NOW()) |
+-------------+--------------+
|        2019 |            3 |
+-------------+--------------+
```
```sql
-- DAYOFWEEK(): 1-일요일, WEEKDAY(): 0-월요일
SELECT DAYOFWEEK(NOW()), WEEKDAY(NOW());
```
```
+------------------+----------------+
| DAYOFWEEK(NOW()) | WEEKDAY(NOW()) |
+------------------+----------------+
|                4 |              2 |
+------------------+----------------+
```
```sql
-- DAOFYEAR(): 1년 중 며칠이 지났는지 알려줌
SELECT DAYOFYEAR(NOW());
```
```
+------------------+
| DAYOFYEAR(NOW()) |
+------------------+
|               86 |
+------------------+
```
```sql
-- DATE_ADD(), DATE_SUB()
SELECT DATE_ADD(NOW(), interval 5 YEAR), DATE_ADD(NOW(), interval 5 DAY);
```
```
+----------------------------------+---------------------------------+
| DATE_ADD(NOW(), interval 5 YEAR) | DATE_ADD(NOW(), interval 5 DAY) |
+----------------------------------+---------------------------------+
| 2024-03-27 16:48:21              | 2019-04-01 16:48:21             |
+----------------------------------+---------------------------------+
```
<br>

### 3.2. Aggregation Function
- SUM(), AVG(), COUNT(), MAX(), MIN()

### 3.3. 기타
```sql
-- CONVERT()
SELECT CONVERT('2019-5-1', DATE);
SELECT CONVERT(150, CHAR);
SELECT CONVERT('14:06:10', TIME);
```
  
```sql
-- CASE()
-- 업무가 salesman이면 'yes' 이라고하고, 그 외 업무는 'no' 라고 조회
SELECT ename, job, comm,
	CASE 
		WHEN job='salesman' THEN 'yes'
		ELSE 'no'
	END iscomm
FROM scott_emp;
```
```
+--------+-----------+--------+
| ename  | comm      | iscomm |
+--------+-----------+--------+
| SMITH  | CLERK     | no     |
| ALLEN  | SALESMAN  | yes    |
| WARD   | SALESMAN  | yes    |
| JONES  | MANAGER   | no     |
| MARTIN | SALESMAN  | yes    |
| BLAKE  | MANAGER   | no     |
| CLARK  | MANAGER   | no     |
| SCOTT  | ANALYST   | no     |
| KING   | PRESIDENT | no     |
| TURNER | SALESMAN  | yes    |
| ADAMS  | CLERK     | no     |
| JAMES  | CLERK     | no     |
| FORD   | ANALYST   | no     |
| MILLER | CLERK     | no     |
+--------+-----------+--------+
```

```sql
-- COALESCE()
-- 현재 직원들의 총 급여를 조회
SELECT empno, ename, sal, comm, (sal+comm) as total FROM scott_emp; --null값 처리가 안됨
SELECT empno, ename, sal, comm,
	(sal+COALESCE(comm, 0)) as total
	FROM scott_emp;
```
<br>

### 연습문제
```sql
-- 1. 오늘부터 12월 25일까지 몇일이 남았는가?
SELECT DATEDIFF('2019.12.25', NOW());
```
```
+------------------------------------------+
| DAYOFYEAR('2019-12-25')-DAYOFYEAR(NOW()) |
+------------------------------------------+
|                                      273 |
+------------------------------------------+
```
```sql
-- 2. 현재까지 근무한 직원들의 근무일수를 몇주 몇일로 조회(단, 근무일수가 많은 사람 순으로 조회)
SELECT ename, TIMESTAMPDIFF(MONTH, hiredate, NOW()) as work_month, TIMESTAMPDIFF(DAY, hiredate, NOW()) as work_day 
FROM scott_emp 
ORDER BY work_month DESC, work_day DESC;
```
```
+--------+------------+----------+
| ename  | work_month | work_day |
+--------+------------+----------+
| SMITH  |        459 |    13981 |
| ALLEN  |        457 |    13916 |
| WARD   |        457 |    13914 |
| JONES  |        455 |    13875 |
| BLAKE  |        454 |    13846 |
| CLARK  |        453 |    13807 |
| MARTIN |        450 |    13696 |
| TURNER |        450 |    13716 |
| KING   |        448 |    13646 |
| JAMES  |        447 |    13630 |
| FORD   |        447 |    13630 |
| MILLER |        446 |    13579 |
| SCOTT  |        383 |    11667 |
| ADAMS  |        382 |    11633 |
+--------+------------+----------+
```
```sql
-- 3. 10번 부서 직원들 중 현재까지의 근무월수를 계산해서 조회
SELECT ename, hiredate, ROUND(DATEDIFF(NOW(), hiredate)/30) as totalmonth 
FROM scott_emp 
WHERE deptno=10;
```
```
+--------+---------------------+------------+
| ename  | hiredate            | totalmonth |
+--------+---------------------+------------+
| CLARK  | 1981-06-09 00:00:00 |        460 |
| KING   | 1981-11-17 00:00:00 |        455 |
| MILLER | 1982-01-23 00:00:00 |        453 |
+--------+---------------------+------------+
```
```sql
-- 4. 20번 부서 직원들 중 입사일자로부터 13개월이 지난 후의 날짜를 조회
SELECT ename, hiredate, DATE_ADD(hiredate, interval 13 MONTH) as checkingday 
FROM scott_emp 
WHERE deptno=20;
```
```
+-------+---------------------+---------------------+
| ename | hiredate            | checkingday         |
+-------+---------------------+---------------------+
| SMITH | 1980-12-17 00:00:00 | 1982-01-17 00:00:00 |
| JONES | 1981-04-02 00:00:00 | 1982-05-02 00:00:00 |
| SCOTT | 1987-04-19 00:00:00 | 1988-05-19 00:00:00 |
| ADAMS | 1987-05-23 00:00:00 | 1988-06-23 00:00:00 |
| FORD  | 1981-12-03 00:00:00 | 1983-01-03 00:00:00 |
+-------+---------------------+---------------------+
```
```sql
-- 5. 모든 직원에 대해 입사한 달의 근무일수를 조회
SELECT ename, DAYOFMONTH(hiredate) as daysofworking FROM scott_emp;
```
```
+--------+---------------+
| ename  | daysofworking |
+--------+---------------+
| SMITH  |            17 |
| ALLEN  |            20 |
| WARD   |            22 |
| JONES  |             2 |
| MARTIN |            28 |
| BLAKE  |             1 |
| CLARK  |             9 |
| SCOTT  |            19 |
| KING   |            17 |
| TURNER |             8 |
| ADAMS  |            23 |
| JAMES  |             3 |
| FORD   |             3 |
| MILLER |            23 |
+--------+---------------+
```
```sql
-- 6. 현재 급여에 15%가 증가된 급여를 계산하여 사번,이름, 급여, 증가된 급여를 조회(단, 급여는 반올림하여 적용한다.)
SELECT empno, ename, sal, ROUND(sal*1.15) as new_sal FROM scott_emp;
```
```
+-------+--------+------+---------+
| empno | ename  | sal  | new_sal |
+-------+--------+------+---------+
|  7369 | SMITH  |  800 |     920 |
|  7499 | ALLEN  | 1600 |    1840 |
|  7521 | WARD   | 1250 |    1438 |
|  7566 | JONES  | 2975 |    3421 |
|  7654 | MARTIN | 1250 |    1438 |
|  7698 | BLAKE  | 2850 |    3277 |
|  7782 | CLARK  | 2450 |    2818 |
|  7788 | SCOTT  | 3000 |    3450 |
|  7839 | KING   | 5000 |    5750 |
|  7844 | TURNER | 1500 |    1725 |
|  7876 | ADAMS  | 1100 |    1265 |
|  7900 | JAMES  |  950 |    1092 |
|  7902 | FORD   | 3000 |    3450 |
|  7934 | MILLER | 1300 |    1495 |
+-------+--------+------+---------+
```
```sql
-- 7. 이름, 입사일, 입사일로부터 현재까지의 월수, 급여, 급여 총계를 조회
SELECT ename, hiredate, ROUND(DATEDIFF(NOW(), hiredate)/30) as totalmonth, sal, sal*ROUND(DATEDIFF(NOW(), hiredate)/30) as totalsal 
FROM scott_emp;
```
```
+--------+---------------------+------------+------+----------+
| ename  | hiredate            | totalmonth | sal  | totalsal |
+--------+---------------------+------------+------+----------+
| SMITH  | 1980-12-17 00:00:00 |        466 |  800 |   372800 |
| ALLEN  | 1981-02-20 00:00:00 |        464 | 1600 |   742400 |
| WARD   | 1981-02-22 00:00:00 |        464 | 1250 |   580000 |
| JONES  | 1981-04-02 00:00:00 |        462 | 2975 |  1374450 |
| MARTIN | 1981-09-28 00:00:00 |        456 | 1250 |   570000 |
| BLAKE  | 1981-05-01 00:00:00 |        461 | 2850 |  1313850 |
| CLARK  | 1981-06-09 00:00:00 |        460 | 2450 |  1127000 |
| SCOTT  | 1987-04-19 00:00:00 |        389 | 3000 |  1167000 |
| KING   | 1981-11-17 00:00:00 |        455 | 5000 |  2275000 |
| TURNER | 1981-09-08 00:00:00 |        457 | 1500 |   685500 |
| ADAMS  | 1987-05-23 00:00:00 |        388 | 1100 |   426800 |
| JAMES  | 1981-12-03 00:00:00 |        454 |  950 |   431300 |
| FORD   | 1981-12-03 00:00:00 |        454 | 3000 |  1362000 |
| MILLER | 1982-01-23 00:00:00 |        453 | 1300 |   588900 |
+--------+---------------------+------------+------+----------+
```
```sql
-- 8. 업무가 analyst이면 급여를 10%증가시키고 clerk이면 15%, manager이면 20%증가 시켜서 이름, 업무, 급여, 증가된 급여를 조회
SELECT ename, job, sal, 
	CASE 
    	WHEN job='analyst' THEN ROUND(sal*1.10,1) 
        WHEN job='clerk' THEN ROUND(sal*1.15,1) 
        WHEN job='manager' THEN ROUND(sal*1.20) 
        ELSE 'no' 
	END new_sal 
FROM scott_emp;
```
```
+--------+-----------+------+---------+
| ename  | job       | sal  | new_sal |
+--------+-----------+------+---------+
| SMITH  | CLERK     |  800 | 920.0   |
| ALLEN  | SALESMAN  | 1600 | no      |
| WARD   | SALESMAN  | 1250 | no      |
| JONES  | MANAGER   | 2975 | 3570    |
| MARTIN | SALESMAN  | 1250 | no      |
| BLAKE  | MANAGER   | 2850 | 3420    |
| CLARK  | MANAGER   | 2450 | 2940    |
| SCOTT  | ANALYST   | 3000 | 3300.0  |
| KING   | PRESIDENT | 5000 | no      |
| TURNER | SALESMAN  | 1500 | no      |
| ADAMS  | CLERK     | 1100 | 1265.0  |
| JAMES  | CLERK     |  950 | 1092.5  |
| FORD   | ANALYST   | 3000 | 3300.0  |
| MILLER | CLERK     | 1300 | 1495.0  |
+--------+-----------+------+---------+
```
```sql
-- 9. 이름의 첫글자가 k보다 크고 y보다 작은 직원의 이름, 부서, 업무를 조회하시오.
SELECT ename, job, empno FROM scott_emp 
	WHERE LEFT(ename, 1) > 'k' AND LEFT(ename, 1) < 'y'
```
``` 
+--------+----------+-------+
| ename  | job      | empno |
+--------+----------+-------+
| SMITH  | CLERK    |  7369 |
| WARD   | SALESMAN |  7521 |
| MARTIN | SALESMAN |  7654 |
| SCOTT  | ANALYST  |  7788 |
| TURNER | SALESMAN |  7844 |
| MILLER | CLERK    |  7934 |
+--------+----------+-------+
```



